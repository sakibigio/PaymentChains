%% Payment Chains
% (c) 
% version with only consumption, no production. 
clear; close all;
params.tol=10e-6;
params.printinfo=0;
params.printit=0;

%%%%%%%%%%%%%
% Parameters
%%%%%%%%%%%%%
% Value functions - Partial Equilibrium
epsilon=10e-10;
params.N_b=1000;
Val_Iter_params;

% Support of values of debt
range=[-1 params.b_bar-epsilon]    ;
B_vec=linspace(range(1),range(end),params.N_b); % grid space
params.B_vec=B_vec;
params.range=range;

%% Load Functions
Val_Iter_functions;

%% Main Iteration
[V0,policies,B_exit_num]=solveValueFunction(B_vec,funcs,params);

%% Computing Conjectured Value after which you do not exit
% Tv_iter=Tv(B_vec,Bast);
% [V_Bast,I]=max(Tv_iter(Tv_iter==real(Tv_iter)));

%% Main Plots
Val_Iter_plots(params, funcs, V0, policies, B_exit_num);

%% Simulated Paths
T=25; % periods
init_bs = (200:100:750); % initial conditions
% init_bs = [10 N_b-10 N_b/2]; % initial conditions

% compute histories
[hist]=Val_iter_sim(T,init_bs,B_vec,policies);

% plot histories
Val_Iter_simplots(hist);


%% Backwards Solution Using Euler Equation - Tests
% [1] Better done with a while loop
c_star=1+Bstar*(1/R-1);
c_path=c_star;
E_path=c_path;
Q_path=0*c_path+1;
B_path=Bstar;
B_aux=B_tilde-0.001;
while B_path(1)<B_tilde
    c_aux=(beta*R*q)^(-1)*c_path(1);
    B_aux=1/q+B_path(1)/(q*R)-c_aux+(q-1)*B_tilde/q;
    Q_aux=-(q-1)*(B_tilde-B_aux)/c_aux+q;
    B_check=(1+B_path(1)/R-Q_aux*c_aux)-B_aux;
    if B_aux<B_tilde
        c_path=[c_aux; c_path];    
        B_path=[B_aux; B_path];
        Q_path=[Q_aux; c_path];
    else
        uB_aux=1+B_path(1)/R-q*c_aux;
        c_path=[c_aux; c_path];    
        B_path=[B_aux; B_path];
        Q_path=[Q_aux; c_path];
        break
    end
end
iter=0;
c_aux=(beta*R*q)^(-1)*c_path(2);
while B_path(1)<B_exit_num
    B_aux=1+B_path(1)/R-q*c_aux;
    Q_aux=q;
    c_path=[c_aux; c_path];    
    B_path=[B_aux; B_path];
    Q_path=[Q_aux; c_path];
    if length(c_path)>20
        break
    end
    c_aux=(beta*R)^(-1)*c_path(1);
end
T_trans=length(c_path)-1;

figure
% Colors
color_t1=[0.7 0.7 0.7];
color_t0=[0.0 0.0 0.6];
%fplot(@(B) val_high(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t0); hold on; axis tight;
% fplot(@(B) val_low(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t1); grid on;
% fplot(@(B) val_high(B)+log(1/q)/(1-beta),range,'LineWidth',3,'LineStyle',':','Color',color_t1); hold on; axis tight;
% plot(B_vec,C_high(B_vec),'LineWidth',2,'LineStyle',':','Color','k'); 
plot(B_vec,C_out,'LineWidth',2,'LineStyle','-','Color','k'); drawnow; grid on; hold on;
legend('$C(B;\tilde{B}>0)$','Interpreter','Latex','AutoUpdate','off','Box','Off')
yvals=ylim; xvals=xlim;
set(gca,'XTick',Bstar,'XTickLabel',[]);
set(gca,'YTick',[yvals(1) yvals(2)],'YTickLabel',[]);
yTicks = get(gca,'ytick');
xTicks = get(gca, 'xtick');
grid on; yvals=ylim; line([Bstar Bstar],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
grid on; yvals=ylim; line([Bast Bast],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
grid on; yvals=ylim; line([B_tilde B_tilde],[yvals(1) yvals(2)],'Color',[0.5 0.5 0.5],'LineWidth',1,'LineStyle','-.'); grid minor;
% grid on; yvals=ylim; line([B_exit B_exit],[yvals(1) yvals(2)],'Color',[0.5 0.0 0.0],'LineWidth',1,'LineStyle','-.'); grid minor;
grid on; yvals=ylim; line([B_exit_num B_exit_num],[yvals(1) yvals(2)],'Color',[0.5 0.0 0.0],'LineWidth',1,'LineStyle','-.'); grid minor;
for TT=(T_trans:-1:2)
    scatter(B_path(TT),c_path(TT),'r*');
end
% grid on; yvals=ylim; line([Bhat(B_tilde,B_tilde) Bhat(B_tilde,B_tilde)],[yvals(1) yvals(2)],'Color',[0.5 0.5 0.5],'LineWidth',1,'LineStyle',':');
text(xTicks(1),yTicks(1)-0.1,'$B^{\star}$', 'HorizontalAlignment','Center','VerticalAlignment','bottom','interpreter', 'latex');
text(Bast,yTicks(1)-0.1,'$B^{\ast}(\tilde{B})$', 'HorizontalAlignment','Center','VerticalAlignment','bottom','interpreter', 'latex');
text(B_tilde,yTicks(1)-0.1,'$\tilde{B}$', 'HorizontalAlignment','Center','VerticalAlignment','bottom','interpreter', 'latex'); hold on;


% [2] Computing Backward Sets - Compute Maximum T
cond=0; T=0; gamma=beta/q;
while cond==0
    T=T+1;
    left=0;
    for tt=0:T-1
        left=left+gamma^(tt)*(1-q^(-T+tt));
    end
    right=0;
    for tt=0:T
        right=right+gamma^(tt)*(1-q^(-T+tt-1));
    end
    if left<1&&right>1
        cond=1;
    end
%     if T>10;
%         break;
%     end
end

% alternative sum
cond=0; T=0;
scale_l=@(t) (1-gamma^(t))/(1-gamma)-q^(-t)*(1-beta^t)/(1-beta);
while cond==0
    T=T+1;
    left=(1-gamma^(T))/(1-gamma)-q^(-T)*(1-beta^T)/(1-beta);
    right=(1-gamma^(T+1))/(1-gamma)-q^(-(T+1))*(1-beta^(T+1))/(1-beta);
    if left<1&&right>=1
        cond=1;
    end
end

% Compute Backward Sets - entering mixed region
B_back_set=zeros(T+1,1);
B_l=@(T) Bstar+(B_tilde-Bstar)*scale_l(T);
for tt=1:T+1
    B_back_set(tt)=B_l(tt);
end

% Compute Backward Sets - chained region
N_tau=100;
B_back_l_set=zeros(N_tau,1);
B_back_r_set=zeros(N_tau,1);
consf_l=1-q^(-(T))*(B_tilde-Bstar);
consf_r=1-q^(-(T))*(B_tilde-Bstar);
%consf_l_test=1-q^(-T)*(1-(1-beta)*Bstar);
B_l2=@(t) beta^(t+1)*B_l(T)+(1-beta^(t+1))/(1-beta)*consf_l;
B_r2=@(t) beta^(t+1)*B_l(T+1)+(1-beta^(t+1))/(1-beta)*consf_r;
for tt=1:N_tau
    B_back_l_set(tt)=B_l2(tt);
    B_back_r_set(tt)=B_r2(tt);
end
% B_back_lim=1/(1-beta)*consf_l;
B_back_lim=1/(1-beta)*consf_r;

aux=0;
for tt=1:T
    aux=aux+beta^(tt-1)*log(q^(tt)*q^(-(T+1))*(B_tilde-Bstar));
end

V_d_bound=zeros(N_tau,1);
for tt=1:N_tau    
    V_d_bound(tt)=beta^(tt+1)*aux+(1-beta^(tt+1))*log(q^(-(T+1))*(B_tilde-Bstar))/(1-beta)+beta^(T+tt+1)*log((B_tilde-Bstar))/(1-beta);
end



figure('Name','Backward Sets','NumberTitle','off')
% Colors
color_t1=[0.7 0.7 0.7];
color_t0=[0.0 0.0 0.6];
fplot(@(B) val_high(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t0); hold on; axis tight;
fplot(@(B) val_low(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t1); grid on;
% fplot(@(B) val_high(B)+log(1/q)/(1-beta),range,'LineWidth',3,'LineStyle',':','Color',color_t1); hold on; axis tight;
plot(B_vec,V0,'LineWidth',2,'LineStyle','-','Color','k'); drawnow;
legend('$\bar{V}$','$\underbar{V}$','$V_ss(B,\tilde{B})$','Interpreter','Latex','AutoUpdate','off','Box','Off')
yvals=ylim; xvals=xlim;
set(gca,'XTick',Bstar,'XTickLabel',[]);
set(gca,'YTick',[yvals(1) yvals(2)],'YTickLabel',[]);
yTicks = get(gca,'ytick');
xTicks = get(gca, 'xtick');
grid on; yvals=ylim; line([Bstar Bstar],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
% Hi grid on; yvals=ylim; line([Bast Bast],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
grid on; yvals=ylim; line([B_tilde B_tilde],[yvals(1) yvals(2)],'Color',[0.5 0.5 0.5],'LineWidth',1,'LineStyle','-.'); grid minor;
% grid on; yvals=ylim; line([B_exit B_exit],[yvals(1) yvals(2)],'Color',[0.5 0.0 0.0],'LineWidth',1,'LineStyle','-.'); grid minor;
grid on; yvals=ylim; line([B_exit_num B_exit_num],[yvals(1) yvals(2)],'Color',[0.5 0.0 0.0],'LineWidth',1,'LineStyle','-.'); grid minor;
%for tt=1:N_tau
text(xTicks(1),yTicks(1)-0.3,'$B^{\star}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14);
% text(Bast,yTicks(1)-0.3,'$B^{\ast}(\tilde{B})$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14);
text(B_tilde,yTicks(1)-0.3,'$\tilde{B}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14); hold on;
text(b_bar,yTicks(1)-0.3,'$\bar{B}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14); hold on;
text(B_exit_num,yTicks(1)-0.3,'$B^{h}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14); hold on;
plot(B_back_l_set,V_d_bound,'b*');
plot(B_back_r_set(1:end-1),V_d_bound(2:end),'g*');
for tt=1:T+1
    grid on; yvals=ylim; line([B_back_set(tt) B_back_set(tt)],[yvals(1) yvals(2)],'Color',[0.1 0.3 0.5],'LineWidth',0.5,'LineStyle',':'); grid minor;
end
for tt=1:N_tau
    grid on; yvals=ylim; line([B_back_l_set(tt) B_back_l_set(tt)],[yvals(1) yvals(2)],'Color',[0.9 0.3 0.5],'LineWidth',0.7,'LineStyle',':'); grid minor;
    grid on; yvals=ylim; line([B_back_r_set(tt) B_back_r_set(tt)],[yvals(1) yvals(2)],'Color',[0.2 0.6 0.5],'LineWidth',0.7,'LineStyle',':'); grid minor;
end
grid on; yvals=ylim; line([B_back_lim B_back_lim],[yvals(1) yvals(2)],'Color',[0.5 0.6 0.6],'LineWidth',1,'LineStyle','-.'); grid minor;


%end
% for tt=1:T+1
%     grid on; yvals=ylim; line([B_back_set(tt) B_back_set(tt)],[yvals(1) yvals(2)],'Color',[0.1 0.3 0.5],'LineWidth',0.5,'LineStyle',':'); grid minor;
% end
% for tt=1:N_tau
%     grid on; yvals=ylim; line([B_back_l_set(tt) B_back_l_set(tt)],[yvals(1) yvals(2)],'Color',[0.9 0.3 0.5],'LineWidth',1,'LineStyle',':'); grid minor;
%     grid on; yvals=ylim; line([B_back_r_set(tt) B_back_r_set(tt)],[yvals(1) yvals(2)],'Color',[0.2 0.6 0.5],'LineWidth',1,'LineStyle',':'); grid minor;
% end
grid on; yvals=ylim; line([B_back_lim B_back_lim],[yvals(1) yvals(2)],'Color',[0.5 0.6 0.6],'LineWidth',1,'LineStyle','-.'); grid minor;
if printit==1
    orient landscape;
    % saveas(gcf,'F_valuefunction','pdf');
    ax= gca;
    exportgraphics(ax,'F_valuefunction_full.pdf','BackgroundColor','none');
end

figure('Name','Backward Sets (Debt Policy)','NumberTitle','off')
% Colors
color_t1=[0.7 0.7 0.7];
color_t0=[0.0 0.0 0.6];
%fplot(@(B) val_high(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t0); hold on; axis tight;
% fplot(@(B) val_low(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t1); grid on;
% fplot(@(B) val_high(B)+log(1/q)/(1-beta),range,'LineWidth',3,'LineStyle',':','Color',color_t1); hold on; axis tight;
plot(B_vec,Bp_out,'LineWidth',2,'LineStyle','-','Color','k'); grid on; drawnow; hold on;
plot(B_vec,B_vec,'LineWidth',2,'LineStyle',':','Color','k');
legend('$B''$','$B$','Interpreter','Latex','AutoUpdate','off','Box','Off','Location','northwest')
yvals=ylim; xvals=xlim;
set(gca,'XTick',Bstar,'XTickLabel',[]);
set(gca,'YTick',[yvals(1) yvals(2)],'YTickLabel',[]);
yTicks = get(gca,'ytick');
xTicks = get(gca, 'xtick');
line([xvals(1) xvals(2)],[Bstar Bstar],'Color','k','LineWidth',1,'LineStyle',':');
line([xvals(1) xvals(2)],[B_tilde B_tilde],'Color','k','LineWidth',1,'LineStyle',':');
yvals=ylim; line([Bstar Bstar],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
yvals=ylim; line([Bast Bast],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
yvals=ylim; line([B_tilde B_tilde],[yvals(1) yvals(2)],'Color',[0.5 0.5 0.5],'LineWidth',1,'LineStyle','-.'); % grid minor;
yvals=ylim; line([B_exit_num B_exit_num],[yvals(1) yvals(2)],'Color',[0.5 0.0 0.0],'LineWidth',1,'LineStyle','-.'); % grid minor;
% grid on; yvals=ylim; line([Bhat(B_tilde,B_tilde) Bhat(B_tilde,B_tilde)],[yvals(1) yvals(2)],'Color',[0.5 0.5 0.5],'LineWidth',1,'LineStyle',':');
text(xTicks(1),yTicks(1)-0.3,'$B^{\star}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14);
text(Bast,yTicks(1)-0.3,'$B^{\ast}(\tilde{B})$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14);
text(B_tilde,yTicks(1)-0.3,'$\tilde{B}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14); hold on;
text(b_bar,yTicks(1)-0.3,'$\bar{B}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14); hold on;
text(B_exit_num,yTicks(1)-0.3,'$B^{h}$', 'HorizontalAlignment','Center','VerticalAlignment','top','interpreter', 'latex','FontSize',14); hold on;
for tt=1:T+1
    grid on; yvals=ylim; line([B_back_set(tt) B_back_set(tt)],[yvals(1) yvals(2)],'Color',[0.1 0.3 0.5],'LineWidth',0.5,'LineStyle',':'); grid minor;
end
for tt=1:N_tau
    grid on; yvals=ylim; line([B_back_l_set(tt) B_back_l_set(tt)],[yvals(1) yvals(2)],'Color',[0.9 0.3 0.5],'LineWidth',0.7,'LineStyle',':'); grid minor;
    grid on; yvals=ylim; line([B_back_r_set(tt) B_back_r_set(tt)],[yvals(1) yvals(2)],'Color',[0.2 0.6 0.5],'LineWidth',0.7,'LineStyle',':'); grid minor;
end
grid on; yvals=ylim; line([B_back_lim B_back_lim],[yvals(1) yvals(2)],'Color',[0.5 0.6 0.6],'LineWidth',1,'LineStyle','-.'); grid minor;
if printit==1    
    orient landscape;
  %  set(gca,'LooseInset',get(gca,'TightInset'));
  %  saveas(gcf,'F_bprime','pdf');
    ax = gca;
    exportgraphics(ax,'F_bprime_full.pdf','BackgroundColor','none');
end

figure('Name','Backward Sets (C Policy)','NumberTitle','off')
% Colors
color_t1=[0.7 0.7 0.7];
color_t0=[0.0 0.0 0.6];
%fplot(@(B) val_high(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t0); hold on; axis tight;
% fplot(@(B) val_low(B),range,'LineWidth',1.5,'LineStyle','-','Color',color_t1); grid on;
% fplot(@(B) val_high(B)+log(1/q)/(1-beta),range,'LineWidth',3,'LineStyle',':','Color',color_t1); hold on; axis tight;
% plot(B_vec,C_high(B_vec),'LineWidth',2,'LineStyle',':','Color','k'); 
plot(B_vec,C_out,'LineWidth',2,'LineStyle','-','Color','k'); drawnow; grid on; hold on;
legend('$C(B;\tilde{B}>0)$','Interpreter','Latex','AutoUpdate','off','Box','Off')
yvals=ylim; xvals=xlim;
set(gca,'XTick',Bstar,'XTickLabel',[]);
set(gca,'YTick',[yvals(1) yvals(2)],'YTickLabel',[]);
yTicks = get(gca,'ytick');
xTicks = get(gca, 'xtick');
grid on; yvals=ylim; line([Bstar Bstar],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
%grid on; yvals=ylim; line([Bast Bast],[yvals(1) yvals(2)],'Color','k','LineWidth',1,'LineStyle','--');
grid on; yvals=ylim; line([B_tilde B_tilde],[yvals(1) yvals(2)],'Color',[0.5 0.5 0.5],'LineWidth',1,'LineStyle','-.'); grid minor;
% grid on; yvals=ylim; line([B_exit B_exit],[yvals(1) yvals(2)],'Color',[0.5 0.0 0.0],'LineWidth',1,'LineStyle','-.'); grid minor;
grid on; yvals=ylim; line([B_exit_num B_exit_num],[yvals(1) yvals(2)],'Color',[0.5 0.0 0.0],'LineWidth',1,'LineStyle','-.'); grid minor;
% for TT=(T_trans:-1:2)
%     scatter(B_path(TT),c_path(TT),'r*');
% end
% grid on; yvals=ylim; line([Bhat(B_tilde,B_tilde) Bhat(B_tilde,B_tilde)],[yvals(1) yvals(2)],'Color',[0.5 0.5 0.5],'LineWidth',1,'LineStyle',':');
text(xTicks(1),yTicks(1)-0.1,'$B^{\star}$', 'HorizontalAlignment','Center','VerticalAlignment','bottom','interpreter', 'latex');
%text(Bast,yTicks(1)-0.1,'$B^{\ast}(\tilde{B})$', 'HorizontalAlignment','Center','VerticalAlignment','bottom','interpreter', 'latex');
text(B_tilde,yTicks(1)-0.1,'$\tilde{B}$', 'HorizontalAlignment','Center','VerticalAlignment','bottom','interpreter', 'latex'); hold on;
for tt=1:T+1
    grid on; yvals=ylim; line([B_back_set(tt) B_back_set(tt)],[yvals(1) yvals(2)],'Color',[0.1 0.3 0.5],'LineWidth',0.5,'LineStyle',':'); grid minor;
end
for tt=1:N_tau
    grid on; yvals=ylim; line([B_back_l_set(tt) B_back_l_set(tt)],[yvals(1) yvals(2)],'Color',[0.9 0.3 0.5],'LineWidth',0.7,'LineStyle',':'); grid minor;
    grid on; yvals=ylim; line([B_back_r_set(tt) B_back_r_set(tt)],[yvals(1) yvals(2)],'Color',[0.2 0.6 0.5],'LineWidth',0.7,'LineStyle',':'); grid minor;
end
grid on; yvals=ylim; line([B_back_lim B_back_lim],[yvals(1) yvals(2)],'Color',[0.5 0.6 0.6],'LineWidth',1,'LineStyle','-.'); grid minor;
if printit==1    
    orient landscape;
  %  set(gca,'LooseInset',get(gca,'TightInset'));
  %  saveas(gcf,'F_bprime','pdf');
    ax = gca;
    exportgraphics(ax,'F_cons_full.pdf','BackgroundColor','none');
end

%% Functions
function [V_out,policies,B_exit_num]=solveValueFunction(B_vec,funcs,params)
    % unpack parameters
    printinfo=params.printinfo;
    B_tilde=params.B_tilde;
    tol=params.tol;
    E=funcs.E;
    C_w=funcs.C_w;
    S_w=funcs.S_w;
    X_w=funcs.X_w;
    val_low=funcs.val_low;
    
    % initialize values
    V0=val_low(B_vec); V_out=V0; C_out=0*V_out; S_out=0*V_out; X_out=0*V_out; Bp_out=0*V_out;
    
    % reset tolerance to enter loop
    val_gap=2*tol;

    % while loop iteration
    while val_gap>tol
        % print information
        if printinfo
            plot(B_vec,V0,'LineWidth',1,'LineStyle',':'); drawnow;
            disp(['Val at iter:' num2str(val_gap)]);
        end

        % print information
        bb=0;
        for B=B_vec
            bb=bb+1;
            % maximize value function based on cubic spline
            Tv=@(B_p,B) log(C_w(E(B_p,B),B,B_tilde))+params.beta*interp1(B_vec,V0,B_p,'cubic');
            % compute all possible values
            Tv_iter=Tv(B_vec,B);
            index=(imag(Tv_iter)==0);
            % evaluate at optimum to obtain solution
            [V_out(bb),I]=max(Tv_iter(index));
            Bp_aux=B_vec(index);
            % update solutions
            C_out(bb)=C_w(E(Bp_aux(I),B),B,B_tilde);
            S_out(bb)=S_w(E(Bp_aux(I),B),B,B_tilde);
            X_out(bb)=X_w(E(Bp_aux(I),B),B,B_tilde);
            Bp_out(bb)=Bp_aux(I);
        end
        val_gap=max(abs(V_out-V0));
        V0=V_out;
    end
    % Numerical Exit point
    B_exit_num=min(B_vec(abs(V0-val_low(B_vec))<10e-10));
    
    % recording policies
    policies.C_out=C_out;
    policies.S_out=S_out;
    policies.X_out=X_out;
    policies.Bp_out=Bp_out;
end

